%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Roux-Sibilon / Delmotte / Goffaux % June 2022% Stimuli to measure (and modulate with adaptation) the radial bias:% - PATCH stimuli: the noise patch to detect in the periphery%   (1/f noise filtered in orientation, multiple noise samples and multiple contrasts)% - ADAPTOR stimuli: the large noise samples that are used to adapt the 'full' visual field%   to a given orientation.%   (1/f noise filtered in orientation (and also not filtered/isotropic), multiple samples)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%pkg load image % for Octaveclear allclose all% directory to write imagesoutputfolder = 'C:\Users\arouxsibilon\OneDrive - UCL\Rprojects\2022_RadApt_filterednoise\...stimuli\'%outputfolder = 'C:\Users\alexi\OneDrive - UCL\Rprojects\2022_RadApt_filterednoise\...stimuli\'%outputfolder = 'C:\Users\humanvisionlab\Documents\dossierpartageubuntu\Pauline\RadApt_filterednoise\...stimuli\'mkdir(outputfolder)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PATCH% Make SMALL filtered noise stimuli (the noise patch to detect)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Number of patch samplespatchsamples = linspace(1,10,10)% Contrast levels?%RMScontrasts = linspace(0.005,0.03,10)% contrast & lum settingsmeanLum = 0.5;RMS = 0.2;% size of the patchpatchsize = 500% size of the gaussian apperture (RADIUS, not diameter)radius = 200 %(radius)band = 200 % (gaussian modulation)% DoLogGabor parametersFreqPeak = 50; FreqSigma = 1000; % bandwidth on the SF dimension(in octaves)thetasig = 15; % bandwidth(or SD???) on the orientation dimensionThetaSigma = (pi/180).*(thetasig); % bandwidth in radians    % create mask ('flat' gaussian)mask = MakeCosineWindow([patchsize patchsize],radius,band,0,0); %[size in pixels], and 0,0 is the position of the apperturefigure;imshow(mask);% create a 'background' matrixallgrey = zeros(patchsize,patchsize);      allgrey = allgrey + meanLum;  figure;imshow(allgrey);##%% Make the samples##Angle = 0; ##for thepatch = 1:length(patchsamples)##  ##  % noise pattern        ##  noiz = spatialPattern([patchsize patchsize],-1.5);%[size in pixels], + the slope of the 1/f noise distribution##  ##  for theRMS = 1:length(RMScontrasts)##    RMS = RMScontrasts(theRMS)    ##    noiz =(noiz-min(min(noiz)))./(max(max(noiz))-min(min(noiz)));##    noiz = (noiz - mean2(noiz))/std2(noiz);##    noiz = noiz*RMS + meanLum;##%    figure;imshow(noiz);##   ##    ##    % filter noise##    normmask = (noiz - mean2(noiz))/std2(noiz);##    [mean2(normmask) std2(normmask)]####    thetaAngle = deg2rad(Angle);##    filtim = DoLogGabor(normmask,FreqPeak,FreqSigma,thetaAngle,ThetaSigma,0);##    sample = real(filtim);##    sample = (sample - mean2(sample))/std2(sample);##    [mean2(sample) std2(sample)]##    sample = (sample * RMS) +  meanLum;##    [mean2(sample) std2(sample)]##    %figure;imshow(sample)##    ##    % combine with mask and write for the filtered conditions##    gaussianSample = sample.*mask + allgrey.*(1-mask);##%    figure;imshow(gaussianSample);##    imwrite(gaussianSample,[outputfolder 'patch' num2str(patchsamples(thepatch)) '_RMS' num2str(RMScontrasts(theRMS),2) '.bmp'] ,'bmp')##  end##  ##end%%% Make the samples with high contrastAngle = 0; for thepatch = 1:length(patchsamples)    % noise pattern          noiz = spatialPattern([patchsize patchsize],-1.5);%[size in pixels], + the slope of the 1/f noise distribution    noiz =(noiz-min(min(noiz)))./(max(max(noiz))-min(min(noiz)));  noiz = (noiz - mean2(noiz))/std2(noiz);  noiz = noiz*RMS + meanLum;%    figure;imshow(noiz);     % filter noise  normmask = (noiz - mean2(noiz))/std2(noiz);  [mean2(normmask) std2(normmask)]  thetaAngle = deg2rad(Angle);  filtim = DoLogGabor(normmask,FreqPeak,FreqSigma,thetaAngle,ThetaSigma,0);  sample = real(filtim);  sample = (sample - mean2(sample))/std2(sample);  [mean2(sample) std2(sample)]  sample = (sample * RMS) +  meanLum;  [mean2(sample) std2(sample)]  %figure;imshow(sample)    % combine with mask and write for the filtered conditions  gaussianSample = sample.*mask + allgrey.*(1-mask);  %figure;imshow(gaussianSample);  imwrite(gaussianSample,[outputfolder 'patch' num2str(patchsamples(thepatch)) '.bmp'] ,'bmp')  end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ADAPTOR% Make Large filtered noise stimuli (the adaptor)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% how many samples?nsamples = 10;% contrast & lum settingsmeanLum = 0.5;RMS = 0.3;% size of the gaussian apperture (RADIUS, not diameter)radius = 1000 %(radius)band = 80 % (gaussian modulation)% DoLogGabor parametersFreqPeak = 50; FreqSigma = 1000; % bandwidth on the SF dimension(in octaves)thetasig = 10; % bandwidth(or SD???) on the orientation dimensionThetaSigma = (pi/180).*(thetasig); % bandwidth in radians          % create mask ('flat' gaussian)mask = MakeCosineWindow([2199 2199],radius,band,0,0); %[size in pixels], and 0,0 is the position of the apperturefigure;imshow(mask);% create a 'background' matrixallblack = zeros(2199,2199);        %% Make the samplesAngle = 0; for thesample = 1:nsamples    % noise pattern          noiz = spatialPattern([2199 2199],-1.5);%[size in pixels], + the slope of the 1/f noise distribution  noiz =(noiz-min(min(noiz)))./(max(max(noiz))-min(min(noiz)));  noiz = (noiz - mean2(noiz))/std2(noiz);  noiz = noiz*RMS + meanLum;  %figure;imshow(noiz);  % combine with mask and write for the isotropic condition  gaussianSample = noiz.*mask + allblack.*(1-mask);  %figure;imshow(gaussianSample);  imwrite(gaussianSample,[outputfolder 'iso' num2str(thesample) '.bmp'] ,'bmp')      % filter noise  normmask = (noiz - mean2(noiz))/std2(noiz);  [mean2(normmask) std2(normmask)]  thetaAngle = deg2rad(Angle);  filtim = DoLogGabor(normmask,FreqPeak,FreqSigma,thetaAngle,ThetaSigma,0);  sample = real(filtim);  sample = (sample - mean2(sample))/std2(sample);  [mean2(sample) std2(sample)]  sample = (sample * RMS) +  meanLum;  [mean2(sample) std2(sample)]  %figure;imshow(sample)    % combine with mask and write for the filtered conditions  gaussianSample = sample.*mask + allblack.*(1-mask);  %figure;imshow(gaussianSample);  imwrite(gaussianSample,[outputfolder 'sample' num2str(thesample) '.bmp'] ,'bmp')  end%% create a grey background matrixtruc = zeros(2199,2199);   truc = meanLum;%% Make a grey apperture/background on which the gabor stim will be presentedgaussianGray = truc.*mask + allblack.*(1-mask);figure;imshow(gaussianGray)imwrite(gaussianGray,[outputfolder 'gaussianGray.bmp'] ,'bmp')